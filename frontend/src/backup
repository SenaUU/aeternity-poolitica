// src/App.jsx
import React, { useState, useEffect, useRef } from 'react';
import {
  AeSdkAepp,
  Node,
  BrowserWindowMessageConnection,
  walletDetector,
  Contract
} from '@aeternity/aepp-sdk';

import WalletConnection from './components/WalletConnection';
import Dashboard from './components/Dashboard';
import DepositWithdraw from './components/DepositWithdraw';
import VotingPanel from './components/VotingPanel';
import ExecuteStrategy from './components/ExecuteStrategy';
import './App.css';

// Configuration
const NODE_URL = 'https://testnet.aeternity.io';
const CONTRACT_ADDRESS = 'ct_2hwpMwF6Xo1vEhxcz5BPFZxQ4DjLyVY3P7Md4nsKkyjgthf2zV';

// ACI (Abstract Contract Interface)
const ACI = [{
  "contract": {
    "name": "YieldPool",
    "functions": [
      {
        "name": "init",
        "arguments": [],
        "returns": "YieldPool.state",
        "stateful": false
      },
      {
        "name": "deposit",
        "arguments": [],
        "returns": {"tuple": []},
        "stateful": true,
        "payable": true
      },
      {
        "name": "withdraw",
        "arguments": [{"name": "amount", "type": "int"}],
        "returns": {"tuple": []},
        "stateful": true
      },
      {
        "name": "vote",
        "arguments": [{"name": "strategy", "type": "string"}],
        "returns": {"tuple": []},
        "stateful": true
      },
      {
        "name": "execute_strategy",
        "arguments": [],
        "returns": {"tuple": []},
        "stateful": true
      },
      {
        "name": "reset_voting",
        "arguments": [],
        "returns": {"tuple": []},
        "stateful": true
      },
      {
        "name": "get_total_deposits",
        "arguments": [],
        "returns": "int",
        "stateful": false
      },
      {
        "name": "get_user_balance",
        "arguments": [{"name": "user", "type": "address"}],
        "returns": "int",
        "stateful": false
      },
      {
        "name": "get_votes",
        "arguments": [],
        "returns": {"map": {"key": "string", "value": "int"}},
        "stateful": false
      },
      {
        "name": "get_user_vote_choice",
        "arguments": [{"name": "user", "type": "address"}],
        "returns": {"variant": [{"name": "Some", "args": [{"type": "string"}]}, {"name": "None", "args": []}]},
        "stateful": false
      },
      {
        "name": "get_available_strategies",
        "arguments": [],
        "returns": {"list": "string"},
        "stateful": false
      },
      {
        "name": "is_voting_active",
        "arguments": [],
        "returns": "bool",
        "stateful": false
      },
      {
        "name": "get_contract_balance",
        "arguments": [],
        "returns": "int",
        "stateful": false
      }
    ],
    "state": {
      "record": [
        {"name": "total_deposits", "type": "int"},
        {"name": "balances", "type": {"map": {"key": "address", "value": "int"}}},
        {"name": "votes", "type": {"map": {"key": "string", "value": "int"}}},
        {"name": "user_votes", "type": {"map": {"key": "address", "value": "string"}}},
        {"name": "voting_active", "type": "bool"},
        {"name": "owner", "type": "address"}
      ]
    },
    "type_defs": []
  }
}];

function App() {
  // Core SDK + wallet state
  const [aeSdk, setAeSdk] = useState(null);
  const [account, setAccount] = useState(null);
  const [contract, setContract] = useState(null);
  const [isConnected, setIsConnected] = useState(false);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState('');
  const [walletDetectionActive, setWalletDetectionActive] = useState(false);

  // Contract state
  const [totalDeposits, setTotalDeposits] = useState(0);
  const [userBalance, setUserBalance] = useState(0);
  const [votes, setVotes] = useState({ Safe: 0, Risky: 0, Charity: 0 });
  const [userVote, setUserVote] = useState(null);
  const [votingActive, setVotingActive] = useState(true);

  const initializedRef = useRef(false);
  const detectionRef = useRef(false);
  const timeoutRef = useRef(null);

  useEffect(() => {
    console.log('App component mounted');
    if (!initializedRef.current) {
      initializedRef.current = true;
      initializeAeSdk();
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  useEffect(() => {
    if (contract && account) loadContractData();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [contract, account]);

  // Cleanup timeout on unmount
  useEffect(() => {
    return () => {
      if (timeoutRef.current) clearTimeout(timeoutRef.current);
    };
  }, []);

  // Initialize AeSdkAepp and start detection
  const initializeAeSdk = async () => {
    try {
      setLoading(true);
      console.log('Initializing AeSdkAepp...');
      const node = new Node(NODE_URL);

      const sdk = new AeSdkAepp({
        name: 'Community-Governed Yield Pool',
        nodes: [{ name: 'testnet', instance: node }],
        // network/address change handlers (optional)
        onNetworkChange: (params) => console.log('Network changed:', params),
        onAddressChange: (addresses) => {
          console.log('Address change event:', addresses);
          // when SDK triggers onAddressChange, try to set active account if available
          try {
            if (addresses && addresses.current) {
              const a = Object.keys(addresses.current)[0];
              if (a) setAccount(a);
            }
          } catch (e) { /* ignore */ }
        }
      });

      setAeSdk(sdk);
      console.log('âœ… AeSdkAepp initialized');

      // Start scanning for wallets
      startWalletDetection(sdk);
    } catch (err) {
      console.error('Failed to initialize AeSdkAepp:', err);
      setError('Failed to initialize Aeternity SDK: ' + (err?.message || err));
    } finally {
      setLoading(false);
    }
  };

  // Wallet detection + connect flow (uses walletDetector + BrowserWindowMessageConnection)
  const startWalletDetection = (sdk) => {
    if (!sdk || detectionRef.current || walletDetectionActive) return;
    console.log('Starting wallet detection...');
    detectionRef.current = true;
    setWalletDetectionActive(true);
  
    const scannerConnection = new BrowserWindowMessageConnection();
  
    // will hold the stop function returned by walletDetector
    let stopScan = null;
  
    const stopScanCleanup = () => {
      try { if (stopScan) stopScan(); } catch (e) { /* ignore */ }
      setWalletDetectionActive(false);
      detectionRef.current = false;
    };
  
    const handleWallets = async ({ wallets, newWallet }) => {
      newWallet = newWallet || Object.values(wallets || {})[0];
      if (!newWallet) return;
  
      console.log('Wallet found:', newWallet.info || newWallet);
      try {
        stopScanCleanup(); // stop scanning immediately
        const conn = newWallet.getConnection();
        await sdk.connectToWallet(conn);
        console.log('âœ… connected to wallet via sdk.connectToWallet');
  
        const { address } = await sdk.subscribeAddress('subscribe', 'connected');
        const firstAddress = address && address.current && Object.keys(address.current)[0];
        if (firstAddress) {
          setAccount(firstAddress);
          setIsConnected(true);
          setError('');
          // Clear any pending timeout
          if (timeoutRef.current) {
            clearTimeout(timeoutRef.current);
            timeoutRef.current = null;
          }
          await initializeContract(sdk);
        } else {
          throw new Error('No accounts found. Unlock wallet and allow access.');
        }
      } catch (err) {
        console.error('Wallet connection failed:', err);
        setError(`Wallet connection failed: ${err?.message || err}`);
        stopScanCleanup();
      }
    };
  
    // start detector and keep stop function in stopScan (no redeclaration)
    stopScan = walletDetector(scannerConnection, handleWallets);
  
    timeoutRef.current = setTimeout(() => {
      if (!isConnected && timeoutRef.current) {
        console.warn('No wallet detected in time.');
        setError('Superhero Wallet not detected. Make sure the extension is open and refresh the page.');
        stopScanCleanup();
        timeoutRef.current = null;
      }
    }, 5000);
  };
  

  // Initialize the Contract instance (uses sdk.getContext() for provider info)
  const initializeContract = async (sdk) => {
    try {
      if (!sdk) throw new Error('SDK is not available');
      console.log('Initializing contract instance...');
      const contractInstance = await Contract.initialize({
        ...sdk.getContext(),
        aci: ACI,
        address: CONTRACT_ADDRESS
      });
      setContract(contractInstance);
      console.log('âœ… Contract initialized');
    } catch (err) {
      console.error('Contract initialization failed:', err);
      setError('Contract initialization failed: ' + (err?.message || err));
    }
  };

  // Manual "Connect" button fallback: triggers detection if not connected
  const connectWallet = async () => {
    try {
      setLoading(true);
      setError('');
      if (!aeSdk) throw new Error('SDK not initialized. Refresh the page.');

      if (isConnected) {
        console.log('Already connected');
        return;
      }

      // Try to read any already-subscribed address
      try {
        // subscribeAddress returns address map if a wallet is already connected
        const res = await aeSdk.subscribeAddress('get', 'connected');
        const current = (res && res.address && res.address.current) || {};
        const first = Object.keys(current)[0];
        if (first) {
          setAccount(first);
          setIsConnected(true);
          await initializeContract(aeSdk);
          return;
        }
      } catch (e) {
        // ignore - proceed to start detection
      }

      // start scan (if not active)
      if (!walletDetectionActive && !detectionRef.current) startWalletDetection(aeSdk);
    } catch (err) {
      console.error('Manual wallet connection failed:', err);
      setError(`Connection failed: ${err?.message || err}`);
    } finally {
      setLoading(false);
    }
  };

  // Contract data loader
  const loadContractData = async () => {
    try {
      if (!contract || !account) {
        console.log('Contract or account unavailable', { contract: !!contract, account: !!account });
        return;
      }
      console.log('Loading contract data...');
      const [
        totalDep,
        userBal,
        contractVotes,
        userVoteChoice,
        isVotingActive
      ] = await Promise.all([
        contract.get_total_deposits(),
        contract.get_user_balance(account),
        contract.get_votes(),
        contract.get_user_vote_choice(account),
        contract.is_voting_active()
      ]);

      setTotalDeposits(Number(totalDep?.decodedResult ?? 0n));
      setUserBalance(Number(userBal?.decodedResult ?? 0n));

      const votesObj = contractVotes?.decodedResult ?? {};
      setVotes({
        Safe: Number(votesObj.Safe ?? 0n),
        Risky: Number(votesObj.Risky ?? 0n),
        Charity: Number(votesObj.Charity ?? 0n)
      });

      let vote = null;
      if (userVoteChoice?.decodedResult) {
        const entries = Object.entries(userVoteChoice.decodedResult);
        if (entries.length > 0) {
          const [constructorName, args] = entries[0];
          if (constructorName === 'Some' && Array.isArray(args) && args.length > 0) {
            vote = args[0];
          }
        }
      }
      setUserVote(vote);

      setVotingActive(Boolean(isVotingActive?.decodedResult ?? true));

      console.log('âœ… Contract data loaded');
    } catch (err) {
      console.error('Failed to load contract data:', err);
      setError('Failed to load contract data: ' + (err?.message || err));
    }
  };

  // Action handlers (deposit/withdraw/vote/execute) mirror your previous implementation
  const handleDeposit = async (amount) => {
    if (!contract) throw new Error('Contract not initialized');
    setLoading(true);
    try {
      console.log('deposit', amount);
      const res = await contract.deposit({ amount: BigInt(amount) });
      await loadContractData();
      return res;
    } finally {
      setLoading(false);
    }
  };

  const handleWithdraw = async (amount) => {
    if (!contract) throw new Error('Contract not initialized');
    setLoading(true);
    try {
      console.log('withdraw', amount);
      const res = await contract.withdraw(BigInt(amount));
      await loadContractData();
      return res;
    } finally {
      setLoading(false);
    }
  };

  const handleVote = async (strategy) => {
    if (!contract) throw new Error('Contract not initialized');
    setLoading(true);
    try {
      console.log('vote', strategy);
      const res = await contract.vote(strategy);
      await loadContractData();
      return res;
    } finally {
      setLoading(false);
    }
  };

  const handleExecuteStrategy = async () => {
    if (!contract) throw new Error('Contract not initialized');
    setLoading(true);
    try {
      console.log('execute strategy');
      const res = await contract.execute_strategy();
      await loadContractData();
      return res;
    } finally {
      setLoading(false);
    }
  };

  return (
    <div className="app">
      <header className="app-header">
        <h1>ðŸŒŸ Community-Governed Yield Pool</h1>
        <p>Deposit AE, vote on strategies, earn yield together!</p>
      </header>

      {error && <div className="error-banner">{error}</div>}

      {!isConnected ? (
        <WalletConnection
          onConnect={connectWallet}
          loading={loading || walletDetectionActive}
        />
      ) : (
        <div className="main-content">
          <Dashboard
            totalDeposits={totalDeposits}
            userBalance={userBalance}
            votes={votes}
            account={account}
          />

          <div className="action-panels">
            <DepositWithdraw
              onDeposit={handleDeposit}
              onWithdraw={handleWithdraw}
              userBalance={userBalance}
              loading={loading}
            />

            <VotingPanel
              votes={votes}
              userVote={userVote}
              onVote={handleVote}
              votingActive={votingActive}
              loading={loading}
            />

            <ExecuteStrategy
              onExecute={handleExecuteStrategy}
              votingActive={votingActive}
              votes={votes}
              loading={loading}
            />
          </div>
        </div>
      )}
    </div>
  );
}

export default App;